#!/usr/bin/env python3
#-*- encoding:utf-8 -*-

from Crypto.Cipher import AES
import zlib
import struct
import zipfile
import os
import sys
import configparser
from PIL import Image, ImageDraw
import numpy as np
import argparse
import tempfile
import shutil

from config import default_menu_img_path,default_radio_img_path


def extractSsf(ssf_file_path, dest_dir):
    """
        解压ssf文件到指定文件夹，文件夹不存在会自动创建
        ssf 文件格式目前有两种，一种是加密过后，一种未加密的zip
    """
    
    # 读取文件的二进制内容
    ssfbin = open(ssf_file_path, 'rb').read()
    
    if ssfbin[:4] == b'Skin': # 通过头四字节判断是否被加密
        # AES 解密内容
        aesKey = b'\x52\x36\x46\x1A\xD3\x85\x03\x66' + \
                 b'\x90\x45\x16\x28\x79\x03\x36\x23' + \
                 b'\xDD\xBE\x6F\x03\xFF\x04\xE3\xCA' + \
                 b'\xD5\x7F\xFC\xA3\x50\xE4\x9E\xD9'
        iv = b'\xE0\x7A\xAD\x35\xE0\x90\xAA\x03' + \
             b'\x8A\x51\xFD\x05\xDF\x8C\x5D\x0F'
        ssfAES = AES.new(aesKey, AES.MODE_CBC, iv)
        decrypted_ssfbin = ssfAES.decrypt(ssfbin[8:])
        
        # zlib 解压内容
        data = zlib.decompress(decrypted_ssfbin[4:]) # 注意要跳过头四字节
        
        def readUint(offset):
            return struct.unpack('I', data[offset:offset+4])[0]
        
        # 整个内容的大小
        size = readUint(0)
        
        # 得到若干个偏移量
        offsets_size = readUint(4)
        offsets = struct.unpack('I'*(offsets_size//4),
                                data[8:8+offsets_size])
        
        # 创建文件夹
        if not os.path.isdir(dest_dir):
            os.mkdir(dest_dir)
        
        for offset in offsets:
            # 得到文件名
            name_len = readUint(offset)
            filename = data[offset+4:offset+4+name_len].decode('utf-16')

            # 得到文件内容
            content_len = readUint(offset+4+name_len)
            content = data[offset+8+name_len:offset+8+name_len+content_len]

            # 写入文件
            open(dest_dir.rstrip(os.sep)+os.sep+filename, 'wb').write(content)

    else:
        
        # 直接 zip 解压
        with zipfile.ZipFile(ssf_file_path) as zf:
            zf.extractall(dest_dir)

def getImageAvg(image_path, area = (0, 0, 0, 0)):
    """
        获取图片的像素平均值
            image_path 图片的路径
            aria 是需要求的平均值的区域，默认整幅图
                格式 area = (x1,x2,y1,y2)
                当 x2 或 y2 为零表示最大值直到边界
                            为负时表示距离最大边界多少的坐标
        返回 (r,g,b) 三元组
    """
    # 读取到图片
    image = Image.open(image_path)
    size = image.size
    
    # 确定区域
    x1 = area[0] % size[0]
    x2 = area[1] % size[0]
    y1 = area[2] % size[1]
    y2 = area[3] % size[1]
    if x2 == 0: x2 = size[0]
    if y2 == 0: y2 = size[1]
    
    if x1 > x2:
        t = x1; x1 = x2; x2 = t
    if y1 > y2:
        t = y1; y1 = y2; y2 = t
    if x1 == x2:
        if x2 != size[0]:
            x2 += 1
        else:
            x1 -= 1
    if y1 == y2:
        if y2 != size[1]:
            y2 += 1
        else:
            y1 -= 1
    
    # 算出区域内所有象素点的平均值
    a = np.asarray(image)
    r = g = b = np.int32(0) #修正转换过程数值溢出
    count = 0
    if a.shape[2] == 4:
        for y in range(y1, y2):
            for x in range(x1, x2):
                if a[y][x][3] > 0:
                    r += a[y][x][0]
                    g += a[y][x][1]
                    b += a[y][x][2]
                    count += 1
    else:
        for y in range(y1, y2):
            for x in range(x1, x2):
                r += a[y][x][0]
                g += a[y][x][1]
                b += a[y][x][2]
                count += 1
    if count == 0:
        count = 1
    r //= count
    g //= count
    b //= count
    return (r, g, b)
    
def rgbDist(c1, c2):
    """
        简单的计算两个颜色之间的距离
    """
    dr = c1[0]-c2[0]
    dg = c1[1]-c2[1]
    db = c1[2]-c2[2]
    return dr*dr+dg*dg+db*db

def rgbDistMax(color, *colors):
    """
        求 colors 中与 color 的距离最大的颜色
    """
    max_d = 0
    max_d_color = colors[0]
    for c in colors:
        cur_d = rgbDist(color, c)
        if max_d < cur_d:
            max_d = cur_d
            max_d_color = c
    return max_d_color

        
# 获取图片大小的函数
def getImageSize(image_file):
    assert image_file
    size = Image.open(image_file).size
    assert size[0] > 0 and size[0] < 65536 and \
           size[1] > 0 and size[1] < 65536
    return size

# 保存一个多边形到 png 文件里
def savePolygon(size, points, color, out_file):
    img = Image.new('RGBA', size)
    draw = ImageDraw.Draw(img)
    draw.polygon(points, fill = color)
    img.save(out_file)

def ssf2fcitx5(skin_dir):
    """
        转换为 fcitx5 格式
        将解压后的 ssf 皮肤，在里面创建出 theme.conf
    """
    
    skin_dir = skin_dir.rstrip(os.sep)
    
    # 确保 skin.ini 文件的存在
    skin_ini = skin_dir + os.sep + 'skin.ini'
    if not os.path.isfile(skin_ini):
        sys.stderr.write('找不到 skin.ini\n')
        return 1
    
    # 为了使其区分大小写，重载 ConfigParser
    class CaseSensitiveConfigParser(configparser.ConfigParser):
        def optionxform(self, optionstr):
            return optionstr
    
    # 读取 skin.ini 文件
    try:
        ssf = CaseSensitiveConfigParser(allow_no_value = True)
        ssf.read(skin_ini, encoding = 'utf-16')
    except:
        sys.stderr.write('读取 skin.ini 失败\n')
        return 2
    
    # 建立 conf 的对象
    skin = CaseSensitiveConfigParser(allow_no_value = True)
    
    skin['Metadata'] = {
        # 皮肤名称
        'Name': ssf['General']['skin_name'],
        
        # 皮肤版本
        'Version': ssf['General']['skin_version'],
        
        # 皮肤作者
        'Author': ssf['General']['skin_author'],
        
        # 描述
        'Description': ssf['General']['skin_info'],

        # 用 DPI 缩放
        'ScaleWithDPI': 'False',
    }
    
    # 将 skin.ini 的颜色转换成 (r,g,b) 三元组
    def colorConv(ssf_color):
        color_int = int(ssf_color, 16)
        r = color_int % 256
        g = (color_int % 65536) // 256
        b = color_int // 65536
        return (r, g, b)

    # 获取图片文件名的函数（获取失败则返回空字符串）
    def getImageConfig(section, key, index = 0):
        if key in ssf[section]:
            image_name_list = ssf[section][key].split(',')
            if index < len(image_name_list):
                image_name = image_name_list[index]
                if os.path.isfile(skin_dir + os.sep + image_name):
                    return image_name
        return ''
    
    # 尝试获取值的函数
    def tryGetValue(section, key):
        if key in ssf[section]:
            return ssf[section][key].strip()
        return ''
        
    # 根据里面所有的图片，根据所设置的拉伸区域确定合适的背景色
    def findBackgroundColor():
        for key in (('Scheme_V1','pic'),
                    ('Scheme_V2','pinyin_pic'),
                    ('Scheme_V2','zhongwen_pic'),
                    ('Scheme_H1','pic'),
                    ('Scheme_H2','pinyin_pic'),
                    ('Scheme_H2','zhongwen_pic'),
                    ):
            # 排除不存在的键值
            image_name = getImageConfig(key[0], key[1])
            if not image_name : continue
            
            # 排除区域不存在
            h_str = tryGetValue(key[0], key[1][:-3] + 'layout_horizontal')
            if not h_str : continue
            v_str = tryGetValue(key[0], key[1][:-3] + 'layout_vertical')
            if not v_str : continue
            
            # 得出区域
            h = h_str.split(',')
            v = v_str.split(',')
            if len(h) != 3 or len(v) != 3: continue
            
            # 排除平铺模式（筛选出是拉伸区域）
            #if int(h[0]) != 0 or int(v[0]) != 0:
            #    continue
            
            return getImageAvg(skin_dir + os.sep + image_name,
                        (int(h[1]),
                         -int(h[2]),
                         int(v[1]),
                         -int(v[2])))
        else:
            return (0, 0, 0)
    
    # 输入框输入的拼音颜色
    input_color = colorConv(ssf['Display']['pinyin_color'])
    
    # 列表中第一个词的颜色
    first_color = colorConv(ssf['Display']['zhongwen_first_color'])
    
    # 列表中其他词的颜色
    other_color = colorConv(ssf['Display']['zhongwen_color'])
    
    # 根据里面所有的图片，根据所设置的拉伸区域确定合适的背景色
    back_color = findBackgroundColor()
    
    # 字体大小（像素）
    font_size = int(ssf['Display']['font_size'])
    
    skin['InputPanel'] = {
        # 字体及其大小
        'Font': 'Sans %d' % font_size,

        # 非选中候选字颜色
        'NormalColor': '#%02x%02x%02x' % other_color,

        # 选中候选字颜色
        'HighlightCandidateColor': '#%02x%02x%02x' % first_color,

        # 高亮前景颜色(输入字符颜色)
        'HighlightColor': '#%02x%02x%02x' % input_color,

        # 输入字符背景颜色
        'HighlightBackgroundColor': '#%02x%02x%02x' % back_color,
        
        #
        'Spacing': 3,
    }

    # 输入框背景图
    input_bar_image = getImageConfig('Scheme_H1', 'pic')
    input_bar_image_size = getImageSize(skin_dir + os.sep + input_bar_image)

    # 水平拉升区域
    lh = tryGetValue('Scheme_H1', 'layout_horizontal')
    if lh:
        lh = tuple(map(lambda s:int(s), lh.split(',')))
    else:
        lh = (0, 2, 2)

    # 垂直拉升区域
    lv = tryGetValue('Scheme_H1', 'layout_vertical')
    if lv:
        lv = tuple(map(lambda s:int(s), lv.split(',')))
    else:
        lv = (0, 2, 2)

    # 拼音边距
    pinyin_marge = tryGetValue('Scheme_H1', 'pinyin_marge')
    if pinyin_marge:
        pinyin_marge = tuple(map(lambda s:int(s), pinyin_marge.split(',')))
    else:
        assert False

    # 候选词边距
    zhongwen_marge = tryGetValue('Scheme_H1', 'zhongwen_marge')
    if zhongwen_marge:
        zhongwen_marge = tuple(map(lambda s:int(s), zhongwen_marge.split(',')))
    else:
        assert False

    # 分隔符长度
    sep = 1 if tryGetValue('Scheme_H1', 'separator') else 0

    # 恒等式：
    #   输入的拼音下方到候选词上方的距离：
    #     pinyin_marge[1] + sep + zhongwen_marge[0] = TextMargin.Bottom + TextMargin.Top
    #   输入的拼音上方到上方边界的距离：
    #     pinyin_marge[0] = ContentMargin.Top + TextMargin.Top
    #   候选词下方到下方边界的距离：
    #     zhongwen_marge[1] = ContentMargin.Bottom + TextMargin.Bottom
    #
    #
    #   这是四元一次方程组，由于只有三个方程，那么随便确定其中一个即可解得其它未知数。
    #     增加的方程：
    #       TextMargin.Bottom = (pinyin_marge[1] + sep + zhongwen_marge[0]) // 2

    distant_pinyin_zhongwen = pinyin_marge[1] + sep + zhongwen_marge[0]

    # 解得：
    TextMargin_Bottom = distant_pinyin_zhongwen // 2
    TextMargin_Top = distant_pinyin_zhongwen - TextMargin_Bottom
    ContentMargin_Top = pinyin_marge[0] - TextMargin_Top
    #ContentMargin_Bottom = zhongwen_marge[1] - TextMargin_Bottom
    ContentMargin_Bottom = input_bar_image_size[1] - \
            ContentMargin_Top - TextMargin_Top - font_size - TextMargin_Bottom - \
            TextMargin_Top - font_size - TextMargin_Bottom

    TextMargin_Top_Left = 5
    TextMargin_Top_Right = 5

    # 文字边距
    skin['InputPanel/TextMargin'] = {
        'Left': TextMargin_Top_Left,
        'Right': TextMargin_Top_Right,
        'Top': TextMargin_Top,
        'Bottom': TextMargin_Bottom,
    }

    # 输入框内容边距
    skin['InputPanel/ContentMargin'] = {
        'Left': max(pinyin_marge[2], zhongwen_marge[2]) - TextMargin_Top_Left,
        'Right': max(pinyin_marge[3], zhongwen_marge[3]) - TextMargin_Top_Right,
        'Top': ContentMargin_Top,
        'Bottom': ContentMargin_Bottom,
    }

    # 输入框背景图
    skin['InputPanel/Background'] = {
        'Image': input_bar_image,
    }

    # 输入框背景图的拉升区域
    skin['InputPanel/Background/Margin'] = {
        'Left': lh[1],
        'Right': lh[2],
        'Top': lv[1],
        'Bottom': lv[2],
    }


    # 绘制高亮的纯色图片
    # menu_highlight_color = rgbDistMax(first_color, input_color, other_color, back_color)
    Image.new('RGBA', (38,23), (0,0,0,0)).save(skin_dir + os.sep + 'highlight.png')

    # 高亮背景
    skin['InputPanel/Highlight'] = {
        'Image': 'highlight.png',
    }
    # 高亮背景边距
    skin['InputPanel/Highlight/Margin'] = {
        'Left': 5,
        'Right': 5,
        'Top': 5,
        'Bottom': 5,
    }

        
    # 绘制 prev.png 和 next.png 颜色为 '%d %d %d' % other_color
    savePolygon((16,24), ((5,6),(5,18),(11,12)), other_color, skin_dir + os.sep + 'next.png')
    savePolygon((16,24), ((11,6),(11,18),(5,12)), other_color, skin_dir + os.sep + 'prev.png')


    # 前一页的箭头
    skin['InputPanel/PrevPage'] = {
        'Image': 'prev.png',
    }
    skin['InputPanel/PrevPage/ClickMargin'] = {
        'Left': 5,
        'Right': 5,
        'Top': 4,
        'Bottom': 4,
    }
    # 后一页的箭头
    skin['InputPanel/NextPage'] = {
        'Image': 'next.png',
    }
    skin['InputPanel/NextPage/ClickMargin'] = {
        'Left': 5,
        'Right': 5,
        'Top': 4,
        'Bottom': 4,
    }

    # 竖排合窗口设置
    Scheme_V1_pic = tryGetValue('Scheme_V1', 'pic')

    # 水平拉升区域
    lh = tryGetValue('Scheme_V1', 'layout_horizontal')
    if lh:
        lh = tuple(map(lambda s:int(s), lh.split(',')))
    else:
        lh = None

    # 垂直拉升区域
    lv = tryGetValue('Scheme_V1', 'layout_vertical')
    if lv:
        lv = tuple(map(lambda s:int(s), lv.split(',')))
    else:
        lv = None

    # 拼音边距
    pinyin_marge = tryGetValue('Scheme_V1', 'pinyin_marge')
    if pinyin_marge:
        pinyin_marge = tuple(map(lambda s:int(s), pinyin_marge.split(',')))
    else:
        pinyin_marge = None

    # 候选词边距
    zhongwen_marge = tryGetValue('Scheme_V1', 'zhongwen_marge')
    if zhongwen_marge:
        zhongwen_marge = tuple(map(lambda s:int(s), zhongwen_marge.split(',')))
    else:
        zhongwen_marge = None

    if Scheme_V1_pic and lh and lv and pinyin_marge and zhongwen_marge:
        # 背景图片
        skin['Menu/Background'] = {
            'Image': Scheme_V1_pic,
        }

        # 背景图片拉升边距
        skin['Menu/Background/Margin'] = {
            'Left': lh[1],
            'Right': lh[2],
            'Top': lv[1],
            'Bottom': lv[2],
        }

        sep = 1 if tryGetValue('Scheme_V1', 'separator') else 0

        # 背景图片内容边距
        horizontal_margin = min(zhongwen_marge[2], zhongwen_marge[3])
        skin['Menu/ContentMargin'] = {
            # 左边距
            'Left': horizontal_margin,

            # 右边距
            'Right': horizontal_margin,

            # 上边距
            'Top': pinyin_marge[0] + pinyin_marge[1] + sep + zhongwen_marge[0],

            # 下边距
            'Bottom': zhongwen_marge[1],
        }
    else:
        # 构建纯色背景

        # 用纯背景色构建出本主题的 menu.png
        img = Image.open(default_menu_img_path)
        a = np.array(img)
        for i in range(len(a)): 
            for j in range(len(a[0])):
                if a[i][j][3]: 
                    a[i][j][0] = back_color[0]
                    a[i][j][1] = back_color[1]
                    a[i][j][2] = back_color[2]
        img = Image.fromarray(a)
        img.save(skin_dir + os.sep + 'menu.png')

        # 背景图片
        skin['Menu/Background'] = {
            'Image': 'menu.png',
        }

        # 背景图片拉升边距
        skin['Menu/Background/Margin'] = {
            'Left': 20,
            'Right': 20,
            'Top': 20,
            'Bottom': 20,
        }

        # 背景图片内容边距
        skin['Menu/ContentMargin'] = {
            # 左边距
            'Left': 8,
            
            # 右边距
            'Right': 8,

            # 上边距
            'Top': 8,
            
            # 下边距
            'Bottom': 8,
        }

    # 绘制高亮的透明图片
    #menu_highlight_color = rgbDistMax((255,255,255), back_color, input_color, first_color, other_color)
    Image.new('RGBA', (38,23), (0,0,0,0)).save(skin_dir + os.sep + 'menu_highlight.png')

    # 高亮背景
    skin['Menu/Highlight'] = {
        'Image': 'menu_highlight.png',
    }
    # 高亮背景边距
    skin['Menu/Highlight/Margin'] = {
        'Left': 10,
        'Right': 10,
        'Top': 5,
        'Bottom': 5,
    }

    # 分隔符颜色
    skin['Menu/Separator'] = {
        'Color': '#%02x%02x%02x' % other_color,
    }

    # 用纯背景色构建出本主题的 radio.png
    img = Image.open(default_radio_img_path)
    a = np.array(img)
    for i in range(len(a)): 
        for j in range(len(a[0])):
            if a[i][j][3]: 
                a[i][j][0] = other_color[0]
                a[i][j][1] = other_color[1]
                a[i][j][2] = other_color[2]
    img = Image.fromarray(a)
    img.save(skin_dir + os.sep + 'radio.png')

    # 复选框图片
    skin['Menu/CheckBox'] = {
        'Image': 'radio.png',
    }

    # 绘制箭头图片
    savePolygon((6,12), ((0,0),(6,6),(0,12)), other_color, skin_dir + os.sep + 'arrow.png')

    # 箭头图片
    skin['Menu/SubMenu'] = {
        'Image': 'arrow.png',
    }

    # 菜单文字项边距
    skin['Menu/TextMargin'] = {
        # 左边距
        'Left': 5,
        
        # 右边距
        'Right': 5,

        # 上边距
        'Top': 5,
        
        # 下边距
        'Bottom': 5,
    }

    skin.write(open(skin_dir + os.sep + 'theme.conf', 'w', encoding="utf-8"), False)
    return 0

def main(args):
    
    # 先从源文件转换成文件夹，如果已经是文件夹了则跳过
    tmp_dir = None
    if os.path.isfile(args.src):
        
        # 确定目标目录
        if args.type == 'zip':
            tmp_dir = tempfile.mkdtemp()
            dest_dir = tmp_dir
        else:
            dest_dir = args.dest
        
        # 开始解压
        extractSsf(args.src, dest_dir)
        
        skin_dir = dest_dir

    elif os.path.isdir(args.src):
        skin_dir = args.src
    else:
        sys.stderr.write('找不到 %s\n' % args.src)
        return 1
    
    result = 255
    if args.type == 'fcitx5':
        result = ssf2fcitx5(skin_dir)
    elif args.type == 'zip':
        file_list = os.listdir(skin_dir)
        with zipfile.ZipFile(args.dest, 'w') as zf:
            for file in file_list:
                zf.write(skin_dir + os.sep + file, file)
        result = 0
    
    if tmp_dir:
        shutil.rmtree(tmp_dir)

    return result

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = \
        'Sogou input method skin file (.ssf file) converter.')
    parser.add_argument('src', help = 'Input path')
    parser.add_argument('dest', help = 'Output path')
    parser.add_argument('--type', '-t',
        help = 'The type of destination path file (folder).' + \
            'The default is fcitx5.',
        default = 'fcitx5',
        choices = ['fcitx5', 'dir', 'zip'])
    args = parser.parse_args()
    
    exit(main(args))
    
    extractSsf(sys.argv[1], sys.argv[2])
    ssf2fcitx(sys.argv[2])

